<style>
  .stories-container {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 16px;
    padding: 16px;
    overflow-x: auto;
    flex-wrap: nowrap;
    -webkit-overflow-scrolling: touch;
    margin-bottom: 16px;
  }

  .story-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    flex-shrink: 0;
  }

  .story-video {
    aspect-ratio: 4/5;
    overflow: hidden;
    background-color: #ddd;
    position: relative; 
    cursor: pointer;
    width: 100%;
  }

  .story-video video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .product-info {
    position: absolute;
    bottom: 0;
    width: 100%;
    text-align: center;
    padding: 3px;
    background:#cec7c7b8;
    border-radius: 0 0 8px 8px;
    display: none;
    z-index: 10;
    transition: opacity 0.3s ease;
  }

  .product-info.visible {
    display: block;
    opacity: 1;
  }

  .product-info img {
    width: 70px;
    height: 70px;
    object-fit: cover;
    cursor: pointer;
  }

  #loading-text {
    color: #888;
    font-size: 13px;
  }

  .product-item {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
  }

  .product-item img {
    flex-basis: 30%;
  }

  .product-item div {
    flex-basis: 65%;
  }
  .info-price{
    display:flex;
    justify-content:center;
    align-items:center;
    gap:10px;
  }
</style>

<div class="stories-container" id="stories-container">
  <p id="loading-text">Loading stories...</p>
</div>

<script>
  async function loadStoriesFromProxy() {
    try {
      const res = await fetch('https://warehouse-mode-nam-oral.trycloudflare.com/app/proxy');
      const responseJson = await res.json();
      console.log('API Response:', responseJson);

      const videos = Array.isArray(responseJson) ? responseJson : responseJson.data || [];
      const container = document.getElementById('stories-container');
      document.getElementById('loading-text')?.remove();

      if (videos.length > 0) {
        for (const item of videos) {
          const storyItem = document.createElement('div');
          storyItem.className = 'story-item';

          const videoContainer = document.createElement('div');
          videoContainer.className = 'story-video';

          const video = document.createElement('video');
          video.src = item.url;
          video.autoplay = true;
          video.loop = false;
          video.muted = true;
          video.playsInline = true;

          const productInfo = document.createElement('div');
          productInfo.className = 'product-info';
          videoContainer.appendChild(productInfo);

          // Store product data and timestamps
          let productsData = [];
          let currentProductIndex = -1;
          let productVisibleTimeout = null;

          if (item.productLinks && item.productLinks.length > 0) {
            // Load product data
            const productPromises = item.productLinks.map(async (link) => {
              try {
                const product = await fetchProductByHandle(link.handle);
                return {
                  ...product,
                  timestamp: link.timestamp,
                  duration: 3// Show each product for 5 seconds by default
                };
              } catch (e) {
                console.error(`Error loading product ${link.handle}:`, e);
                return null;
              }
            });

            productsData = (await Promise.all(productPromises)).filter(Boolean);
            productsData.sort((a, b) => a.timestamp - b.timestamp); // Sort by timestamp
            
            // Set up timeupdate listener
            video.addEventListener('timeupdate', () => {
              const currentTime = video.currentTime;
              let showIndex = -1; //means no product to show
              
              // Find which product should be shown based on current time
              for (let i = 0; i < productsData.length; i++) {
                if (currentTime >= productsData[i].timestamp && 
                    currentTime < (productsData[i].timestamp + productsData[i].duration)) {
                  showIndex = i;
                  break;
                }
              }
              
              // If we found a product to show and it's different from current one
              if (showIndex !== -1 && showIndex !== currentProductIndex) {
                currentProductIndex = showIndex;
                const product = productsData[showIndex];
                
                productInfo.innerHTML = `
                  <div class="product-item" style="margin-bottom: 10px;">
                    <img src="${product.featured_image}" alt="${product.title}" 
                         data-product-url="${product.url}" />
                    <div>
                      <p style="margin: 5px 0 0;"><strong>${product.title}</strong></p>
                      <div class="info-price">
                        <p style="margin: 0 0 5px;">$${product.price}</p>
                        <button class="add-to-cart-btn" 
                                data-variant-id="${product.variantId}" 
                                style="padding: 6px 10px; background: black; color: white; border: none; cursor: pointer; border-radius: 4px;">
                          Add to Cart
                        </button>
                      </div>
                    </div>
                  </div>
                `;
                
                productInfo.classList.add('visible');
                
                // Clear any previous timeout
                if (productVisibleTimeout) {
                  clearTimeout(productVisibleTimeout);
                }
                
                // Set timeout to hide the product after its duration
                productVisibleTimeout = setTimeout(() => {
                  productInfo.classList.remove('visible');
                  currentProductIndex = -1;
                }, productsData[showIndex].duration * 1000);
                
                // Set up event listeners for the new elements
                productInfo.querySelector('img').addEventListener('click', (e) => {
                  e.stopPropagation();
                  window.location.href = e.target.dataset.productUrl;
                });
                
                productInfo.querySelector('.add-to-cart-btn').addEventListener('click', async (e) => {
                  e.stopPropagation();
                  const variantId = e.target.dataset.variantId;
                  try {
                    const res = await fetch('/cart/add', {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                      },
                      body: JSON.stringify({
                        items: [
                          {
                            id: variantId,
                            quantity: 1,
                          },
                        ],
                      }),
                    });
                    const result = await res.json();
                    console.log('Added to cart:', result);
                    e.target.innerText = 'Added!';
                    setTimeout(() => (e.target.innerText = 'Add to Cart'), 2000);
                  } catch (err) {
                    console.error('Error adding to cart:', err);
                    e.target.innerText = 'Error!';
                  }
                });
              } else if (showIndex === -1 && currentProductIndex !== -1) {
                // Hide product info if we passed all timestamps
                currentProductIndex = -1;
                productInfo.classList.remove('visible');
                if (productVisibleTimeout) {
                  clearTimeout(productVisibleTimeout);
                  productVisibleTimeout = null;
                }
              }
            });
          }

          // When video ends, hide any visible product
          video.addEventListener('ended', () => {
            productInfo.classList.remove('visible');
            currentProductIndex = -1;
            if (productVisibleTimeout) {
              clearTimeout(productVisibleTimeout);
              productVisibleTimeout = null;
            }
          });

          videoContainer.appendChild(video);
          storyItem.appendChild(videoContainer);
          container.appendChild(storyItem);
        }
      } else {
        container.innerHTML = '<p>No stories found.</p>';
      }
    } catch (err) {
      console.error('Failed to load stories', err);
      document.getElementById('stories-container').innerHTML = '<p>Error loading stories.</p>';
    }
  }

  async function fetchProductByHandle(handle) {
    try {
      const response = await fetch(`/products/${handle}.js`);
      if (!response.ok) throw new Error('Product not found');
      const product = await response.json();

      const firstVariant = product.variants?.[0];

      return {
        title: product.title,
        featured_image: product.featured_image || '',
        url: `/products/${handle}`,
        price: (firstVariant?.price / 100).toFixed(2),
        variantId: firstVariant?.id,
      };
    } catch (error) {
      console.error(`Error fetching product ${handle}:`, error);
      throw error;
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadStoriesFromProxy);
  } else {
    loadStoriesFromProxy();
  }
</script>

{% schema %}
{
  "name": "stories",
  "target": "section",
  "settings": [
    {
      "type": "text",
      "id": "heading",
      "label": "All Videos",
      "default": "All Videos"
    }
  ]
}
{% endschema %}